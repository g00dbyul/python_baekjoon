# 문제를 해결하기 위해서는 각 아르바이트를 선택할 수 있을 때 최대 급여 합을 구하는 것이 목표입니다.
# 종료일이 시작일보다 빠른 아르바이트들만 이어서 할 수 있으므로, DP(동적 계획법)을 이용해서
# 종료일에 따라 누적된 최대 급여 합계를 저장하면서 문제를 해결하겠습니다.

# 필요한 배열을 받고 처리하는 코드를 작성하겠습니다.

def max_earnings(arr):
    # 아르바이트 종료일 기준으로 정렬 (종료일이 같으면 상관 없고, 종료일 기준으로만 계산)
    arr.sort(key=lambda x: x[1])

    # dp 테이블, 각 인덱스는 해당 아르바이트를 끝냈을 때까지의 최대 급여 합을 저장
    dp = [0] * len(arr)

    # 첫 번째 아르바이트는 그 자체의 급여
    dp[0] = arr[0][2]

    for i in range(1, len(arr)):
        # 현재 아르바이트를 선택할 때 얻는 급여
        current_earnings = arr[i][2]

        # i번째 아르바이트 전의 끝나는 시간을 고려하여 선택 가능한 아르바이트를 찾음
        for j in range(i - 1, -1, -1):
            if arr[j][1] <= arr[i][0]:
                current_earnings += dp[j]
                break

        # i번째 아르바이트까지의 최대 급여는 (이전 최대치 vs 이번 아르바이트를 포함한 값)
        dp[i] = max(dp[i - 1], current_earnings)


    return dp[-1]


# 예시 배열
arr = [
    [1, 2, 1],
    [1, 2, 2],
    [2, 3, 1],
    [3, 4, 1]
]

# 최대 급여 합 구하기
print(
max_earnings(arr)
)
